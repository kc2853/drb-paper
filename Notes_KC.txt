General notes
• (unpredictable, unbiasable, unstoppable) = (1, 0, 1): RANDAO, Algorand, PoW
• (unpredictable, unbiasable, unstoppable) = (1, 1, 0): Dfinity, Ouroboros
• From HydRand: liveness (a correct node knowing R_{r - 1} can know R_r) vs guaranteed output delivery (all correct nodes can output R_r at round r)
• Atomic broadcast ~= consensus (∃reductions both ways)
• Byzantine broadcast (BB): leader broadcasts
• Byzantine agreement (BA): everyone has inputs -> agree on output
• BB ~= leader sends once + BA

1. Feldman's VSS paper
2. Pedersen's paper (DKG)
3. Gennaro's DKG (based on Pedersen)
4. Dfinity
5. Gennaro's DKG Revisited paper
6. ETHDKG paper
7. Schoenmakers PVSS paper
8. RandHerd paper
9. Scrape paper (Cardano?)
10. HydRand
11. Dodis VRF
12. Kate poly commitment
13. DVRF-DRB
14. Timed Commitments
15. RandRunner
16. RandPiper
17. On Bitcoin as a public randomness source
18. Homomorphic Encryption Random Beacon
19. SPURT: Scalable Distributed Randomness Beacon with Transparent Setup
20. Random Oracles in Constantinople: Practical Asynchronous Byzantine Agreement using Cryptography
21. A random zoo: sloth, unicorn, and trx
22. A Pragmatic Introduction to Secure Multi-Party Computation
23. Winning the Caucus Race: Continuous Leader Election via Public Randomness
24. Scalable distributed random number generation based on homomorphic encryption
25. SecRand: A Secure Distributed Randomness Generation Protocol With High Practicality and Scalability
26. RANDCHAIN: Decentralised Randomness Beacon from Sequential Proof-of-Work
27. RandChain: Practical Scalable Decentralized Randomness Attested by Blockchain
28. Economically Viable Randomness
29. Rational Threshold Cryptosystems
30. Secure Multiparty Computations on Bitcoin

1. Feldman's VSS paper
https://www.cs.umd.edu/~gasarch/TOPICS/secretsharing/feldmanVSS.pdf
• Probabilistic encryption
• y_0 is not a commitment to s?
• A_j: permutation?
• SS + homomorphic encryption (DL, ECDL, RSA)

2. Pedersen's paper (DKG)
https://link.springer.com/content/pdf/10.1007/3-540-46416-6_47.pdf
• Parallel Feldman's

3. Gennaro's DKG (based on Pedersen)
https://link.springer.com/content/pdf/10.1007%2F3-540-48910-X_21.pdf
• Joint-Feldman can allow biasing public key (how about private key?)
• Use Pedersen-style VSS (instead of Feldman's): 2 polynomials per player + Pedersen commitments + separate public key extraction step (Step 4)
• 3 correctness properties: 1. can recover the same secret with any honest subset over threshold; 2. public key (g^{secret}) extractable; 3. secret is uniformly distributed
• (C1') > (C1)
• Secrecy property: no information on x is leaked except for public key; simulator SIM argument involved
• Communication model (fully sync), adversary model (static vs adaptive)
• Explains why SIM fails for Joint-Feldman
• Gennaro's DKG: proving correctness properties & secrecy property; remark on generation of h: requires a distributed coin flipping protocol?!
• 2 applications: ElGamal/DSA (randomizer); proactive secret sharing & signature (refresh phase)
• Extension to adaptive adversary: modification to public key extraction step
• Security in partial sync model (Δ)

4. Dfinity
https://dfinity.org/pdf-viewer/library/dfinity-consensus.pdf
• 4 layers
• 1. Identity layer: pseudonymous, register w stake
• 2. Random beacon layer
• 3. Blockchain layer
• 4. Notary layer
• Threshold relay, committee to committee
• Random beacon output -> block proposals -> block notarizations
• Threshold sig: 2 attacks (prediction & aborting); non-interactiveness; uniqueness
• Joint-Feldman DKG: yields a verification vector (commitment to final coefficients)
• Final signature: depends on current round number + previous number

5. Gennaro's DKG Revisited paper
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.12.5426&rep=rep1&type=pdf
• Gennaro's DKG (with Pedersen-VSS): secure but twice more expensive
• Schnorr threshold sig: still secure (paper's main idea!) with Ped-DKG (which uses Feldman-VSS); using 2 DKGs (b/c temp secret key) -> signature
• "Additive" share pooling (paper uses this) vs "polynomial" share pooling
• sk = Σ sk_i (additive): means that sk_i is reconstructed from individual poly (hence worse reusability); need all(!) sk_i to sign
• Setup: computational, communication, adversary, DL assumption, security of threshold sig, simulation proof technique, ROM
• Generalized presentation of the 1/2 -> 3/4 attack for biasing Joint-Feldman
• Main idea: Joint-Feldman should be good enough (even if biasing possible) for threshold sig -> ex: Schnorr threshold sig with additive pooling
• Notion of security for threshold sig: robustness & unforgeability -> proving threshold Schnorr's security via SIM
• Tradeoff: security reduction leads to degradation by a factor compared to security of DLP (discrete log problem) -> need stronger security parameter -> bigger field -> less efficiency

6. ETHDKG paper
https://eprint.iacr.org/2019/985.pdf
• Joint-Feldman DKG + Neji
• Correctness, uniformity, robustness (works even if up to t invalid shares), liveness
• Send encrypted(!) shares via Diffie-Hellman
• Dispute phase: NIZK for DH key (to prevent false accusation)
• Neji: use new generator h (broadcasted later) for group public key; NIZK to show relationship between g & h
• Idea (Neji): decoupling (a la Pedersen-VSS) of verification & extracting public key
• mpk and mpk* (bc Neji and pairing-based?)

7. Schoenmakers PVSS paper
https://www.win.tue.nl/~berry/papers/crypto99.pdf
• PVSS assumes public broadcast
• Chaum-Pedersen subprotocol (DLEQ) for NIZK
• Totally separate individual key pairs for everyone
• Distribution phase (NIZK for encrypted shares) + reconstruction phase (NIZK for decrypted shares)
• Secret shares are different from other protocols
• Share pooling first (via dealer) -> publish share + decryption proof later (not clear from paper)? -- secret can be public?
• Can reuse individual key pairs
• Complexity O(nk) & security theorems (DDH assumption + ROM assumption)
• Z_p not mentioned but still is?
• Alternative scenario: secret not random but from small (potentially not uniformly distributed) set
• G^s (secret) != g^s
• Section 5: electronic voting; voters = dealers while talliers = participants; cheating talliers can know each voter's vote though?
• Section 6: threshold Binding ElGamal, threshold revocable electronic cash, threshold software key escrow

8. RandHerd paper
https://eprint.iacr.org/2016/1067.pdf
• 512 distributed servers -> 32 groups -> every 6 seconds
• Schoenmakers PVSS
• TSS (threshold Schnorr sig) & CoSi (collective signing = multisig aggregation + communication tree)
• RandShare: quasi-DKG but BA (Byzantine agreement) & computes all individual secrets (from individual poly) to compute group secret (sum of indiv secrets)
• RandHound: PVSS groups (parallel PVSS within groups); final random = product of PVSS secrets (Schnorr only for intermediary steps)?!
• RandHound - sharding but retain leadership = SPURT (a la SecRand more than Scrape)
• RandHerd: RandHound for random permutation?; TSS-CoSi; group leader vs cothority; final random = Schnorr sig on timestamp

9. Scrape paper (Cardano?)
https://eprint.iacr.org/2017/216.pdf
• O(nt) exponentiations -> O(n)
• Guaranteed output delivery?
• DDH + ROM or DBS (decisional bilinear square) in the plain model
• Public bulletin board model
• Inner product: share vector & dual's codeword
• Exact number of computations
• Adversarial model (static)
• Coding theory basics
• 3 properties for a PVSS scheme: correctness, verifiability (high probabilistic), IND1-secrecy
• Commitment definition, DLEQ definition
• Shamir's SS ~= Reed-Solomon error correcting code?!
• Scrape's (DDH) PVSS = Schoenmakers PVSS - many exponentiations of poly coeff commitments + Reed-Solomon ECC (hence faster verif complexity)
• Pairing-based (DBS) PVSS = Scrape's DDH PVSS - DLEQ NIZK + pairing + final secret in the form of pairing (not sure why)
• Scrape's randomness protocol (n parallel PVSS): commit -> reveal -> recovery (final random = product of PVSS secrets)
• Commit-reveal (basically) but other players can reconstruct your share if you don't reveal later

10. HydRand
https://eprint.iacr.org/2018/319.pdf
• Scrape's PVSS but no trusted dealer (but actually seems like they have trusted dealer?)
• Byzantine agreement variant?: "defers consensus decisions for up to f + 1 rounds"
• Guaranteed output delivery
• Permissioned setting (fixed players)
• Each round of protocol has 3 phases: propose -> acknowledge -> vote
• Propose: leader proposes a "dataset" which includes his secret (seed for PVSS) value from previous (when its commitment was published already!)
• Acknowledge: each node verifies leader's proposal
• Vote: each node verifies acknowledgement status of other nodes (may involve recovery stage via PVSS in case secret not received)
• Final random = H(previous round's random || PVSS group secret)
• Leader selection (non-interactive): take the most recent random number modulo |potential leader set|
• Potential leader set = all nodes - previous leaders that failed but got reconstructed - leaders for the past f rounds
• Attacker in round r can only attempt to affect round >= r + f + 1
• Hence the claim no trusted dealer
• No DKG

11. Dodis VRF
https://eprint.iacr.org/2004/310.pdf
• VUF (~= unique signature): replace VRF's pseudorandomness with unpredictability
• VUF = just the "proof" part of their VRF construction
• So can hash a unique sig (VUF) to get VRF

12. Kate poly commitment
https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf
• PolyCommit_DL, PolyCommit_Ped
• ZKS (zk set), nearly ZKS (length is leaked), ZK-EDB (zk elementary database)
• CES (content extraction signature), selective show
• Dynamic accumulators
• DL & t-SDH (t-strong Diffie-Hellman) assumptions
• Features: additive homomorphism, unconditional hiding (if only a few evaluations revealed), trapdoor commitment, batch opening (~= batch verification)
• Applications: 1. VSS; 2. nearly ZKS / ZK-EDB; 3. selective show (have Trent sign poly commitment, then prove ɸ(i) = m_i => no need to show all messages!)

13. DVRF-DRB
https://eprint.iacr.org/2020/096.pdf
• Strong pseudorandomness: adversary has (limited) oracle access to PartialEval
• 2 proposed DVRF: DDH-DVRF, GLOW-DVRF
• 3-5x faster than Dfinity
• Cryptographic lib: MCL, RELIC, Libsodium
• DistKG -> PartialEval -> Combine -> Verify
• 1. DDH-DVRF: DistKG (secret key is share on group poly) -> PartialEval (hash^secret, proof is DLEQ NIZK) -> Combine (check NIZK) -> Verify
• 2. GLOW-DVRF: DistKG (intro of g_2 and pairing a la Neji for Verify public key later) -> PartialEval (hash^secret, NIZK) -> Combine (NIZK) -> Verify (pairing)
• Difference in Dfinity-VRF: Combine also uses pairing to prove => less efficient
• Side result: modified BLS (more efficient) = GLOW-DVRF - last step's hash
• Algorand DRB is not strongly pseudorandom?
• Harmony: uses VDF?!
• Verification key (vk) = g^f(i)

14. Timed Commitments
https://www.iacr.org/archive/crypto2000/18800237/18800237.pdf
• 3 properties: verifiable recovery (committer generates proof) + recovery with proof ("VDF" proof s.t. outsiders can verify too) + immunity against parallelism
• Contract signing, honest auction
• Timed signature (with a new definition of valid signature) < timed commitment
• ∃zk proof that the scheme is a timed commitment (from Alice before she commits)
• Basic idea: open (allows faster verification) vs forced open (receiver needs to compute the "VDF")
• Q. Pietrzak's & Wesolowski's can help with efficient verification?
• Section 3 (timed commitment construction): hides message M via BBS generator; but the proof doesn't seem to be related to M?
• Q. paper's intro talks about 2 proofs (committer generating a proof & receiver generating a proof as part of forced-open) vs Section 3's proof -- a gap?

15. RandRunner
https://eprint.iacr.org/2020/942.pdf
• Strongly unique trapdoor VDFs
• No need for continuous Byzantine agreement (BA) due to pseudorandomness <-> true randomness requires some form of BA -- interesting!
• Strong uniqueness: unique even if public parameters adversarially generated (whatever that means); allows result obtained via trapdoor = that by evaluation (what's a counterexample?)
• Wesolowski's is not strongly unique, but Pietrzak's is
• ZKP for safe primes (by Camenisch and Michaels): ensures strong uniqueness?
• Lemma 1: proving strong uniqueness not just uniqueness
• Possible attacks: bias, predict, stall, trick others into accepting bogus
• Countermeasures to adversary selectively sending round output: 1. reliable broadcast O(n^2); 2. gossip protocol O(n log n) -- includes some references
• Unpredictability bounds for RR (round robin) & RS (randomized sampling)
• Note on Unicorn protocol: good for infrequent randomness scenarios
• The entire randomness beacon is essentially a (deterministic) "hash chain" with trapdoor VDFs such that no one person can be super ahead in the chain
• Information theoretically, no randomness?!
• Mathematical bounds for how much one can get ahead
• But dependent on Δ_VDF which is unknown

16. RandPiper
https://eprint.iacr.org/2020/1590.pdf
• GRandPiper (Good): PVSS / static adversary; BRandPiper (Better): VSS(?) / adaptive adversary (can predict for GRandPiper) / but sacrifices complexity a bit
• Quadratic communication per round without using threshold sig
• Reconfiguration friendly (dynamic set of nodes)
• Goal: good communication complexity (quadratic for worst case too); efficient cryptographic scheme (e.g. not VDF); reconfiguration friendly
• SMR (state machine replication) protocol
• Can reduce communication via erasure coding scheme & accumulators
• GRandPiper: PVSS encryption vector; additional "votes"; "to all the honest nodes" (how?); leader doesn't repeat for t epochs (a la HydRand?)
• BRandPiper: iVSS (improved VSS; modified version of eVSS = Kate poly commitment?); homomorphic sum; leader can secret share n shares at once (key insight)
• HydRand: cubic communication complexity worst case; t < n / 3 (but t < n / 2 for RandPiper)
• "Buffering": using last d-th time a node was a leader -> buffer d shares?

17. On Bitcoin as a public randomness source
https://eprint.iacr.org/2015/1015.pdf
• At least 68 bits of min-entropy -> can extract 32 near-uniform bits
• Single-bit lottery: safe up to 50 BTC
• NIST, Random.org, stock market used for election in Takoma Park, BitcoinMegaLottery
• Extractor (sufficient entropy number -> high entropy number)
• Attacks: block withholding attack (could be non-miners in the bribing attacker model); P2P DoS attack (worst-case: Dolev-Yao attacker); idea of transition pruning (lottery as Markov trees & transition matrix)
• Miners use "trusted peers" already
• Proposition (on Bitcoin): OP_BEACON

18. Homomorphic Encryption Random Beacon
https://eprint.iacr.org/2019/1320.pdf
• CE NIZK: "I know m such that g^m"
• Q. the beacon output M is a random point, so how to extract M's discrete log (for a random number)?

19. SPURT: Scalable Distributed Randomness Beacon with Transparent Setup
https://eprint.iacr.org/2021/100.pdf

20. Random Oracles in Constantinople: Practical Asynchronous Byzantine Agreement using Cryptography
https://allquantor.at/blockchainbib/pdf/cachin2000random.pdf

21. A random zoo: sloth, unicorn, and trx
https://eprint.iacr.org/2015/366.pdf
• Sloth (pronounced slow-th) -> unicorn (random beacon) -> trx (application to ECC)
• Section 2: mentions perfect synchrony -> commit-reveal -> last revealer attack
• Mentions RSW time-lock puzzle, time capsules by Bellare/Goldwasser, timed commitments by Boneh/Naor
• Need permutation function (not just modular square roots) in order to prevent potential shortcut?!
• Output of sloth = (initial commitment to input, output, witness)
• Permutation function (in practice) = swap with its neighbor (+/- 1) OR block cipher
• Unicorn: publicize c (commitment to s = s₀ + s₁) -> publicize (s, sloth output, witness); s₀ gathers from crowd; s₁ independently generated (jpg image?!); gives rise to commit-reveal + VDF combo

22. A Pragmatic Introduction to Secure Multi-Party Computation
https://securecomputation.org/docs/pragmaticmpc.pdf
• One interpretation of MPC: participants "secret-share" the inputs/outputs to an MPC protocol
• In practice, participants usually secret-share the inputs in a way that those shares would eventually lead to a correct output
• In other words: instead of input -> f(input) = output, we have something like input -> modified input (an input "share") -> modified output (an output "share") -> output
1) Yao's garbled circuits
• Alice (key generator) & Bob (evaluator)
• Secret sharing: done via Alice's key generation (thus Bob can't know Alice's input) & Alice's oblivious transfer to Bob (thus Alice can't know Bob's input)
• Idea: input -> modified input (used to encrypt the MPC function) -> use modified input to decrypt the MPC function -> output
2) GMW (Goldreich-Micali-Wigderson) protocol
• Secret sharing: done via additive shares (involving randomness) on wires/gates
• Idea: input -> modified input (add with randomness) -> modified output (output share) -> output (randomness cancels out)
3) BGW (Ben-Or-Goldwasser-Wigderson) protocol
• Secret sharing: Shamir's(!) per participant
• Idea: input -> modified input (Shamir shares) -> modified output = f(modified input) -> output (Lagrange interpolation)
• Lindell in his survey paper Secure Multiparty Computation (MPC) notes that this method is not only general, but also the most efficient in practice more often than not?
• Multiplication gates suffer from complexity in BGW due to its degree-reduction step -> optimization using Beaver triples & pre-processing phase
• GMW & BGW suffer b/c number of rounds depends on circuit depth -> BMR (Beaver-Micali-Rogaway) protocol where Yao's garbled circuits idea is generalized to be distributed & parallel -> constant round
• Some techniques turning semi-honest security into malicious security: cut-and-choose, GMW compiler, MPC in the head (state-of-the-art?)
• For outputting an arithmetic sum: #3 (BGW) is relatively more efficient? -> basically repeated iterations of DKG

23. Winning the Caucus Race: Continuous Leader Election via Public Randomness
http://www0.cs.ucl.ac.uk/staff/S.Azouvi/papers/caucus.pdf

24. Scalable distributed random number generation based on homomorphic encryption
https://www.ginar.io/sdrngbohe.pdf
```
• see Pennsylvania Lottery scandal, https://bit.ly/2TXTKZq
• The protocol is divided into rounds with respect to a Requester. In each round, each party runs an instance of a VRF to determine if he is eligible to become a contributor. Afterwards, a contributor encrypts his contribution using the public key of the Requester before publicizing it. We take advantage of the homomorphic property of the El- Gamal cryptosystem on elliptic curve [2] to make it possible for anyone to calculate the sum of all encrypted contributions without performing any decryption. Finally, the Requester uses his private key to decrypt the tallied contribution once and gets the random beacon. He also generates a proof of proper decryption to prove that the random beacon was properly decrypted form the tallied contribution
• A ticket T with respect to the Requester and the received nonce is computed. This ticket is used to determined which parties are eligible (these are called contributors) to contribute to generating random numbers. This stage can be performed by running a smart contract on the PDL
• On input the ticket T, each party runs an instance of VRF functions to check if he is eligible for that ticket and sends a Proof-of-Eligibility (PoE) to the PDL
• Our protocol specifies a threshold T to determine the expected number of parties selected for a ticket. In section VI, we will discuss in more detail about how to choose a proper threshold for a specific expected number of contributors
• contributor Pi has to: choose a value Mi to contribute; use the public key of the Requester to encrypt Mi; sign his contribution with his secret key ski; generate a proof for his contribution PoC as described in line 5 of the algorithm
```
• NV = HERB - key holders + Requester - entropy providers + VRF winners
• Q. can a participant grind through secret keys (b/c not committed beforehand unlike Algorand)?
• HERB says NV doesn't include non-malleability check (NIZK proof of correct encryption)
• Focus on computational complexity
• Misleading communication complexity b/c assumes a blockchain

25. SecRand: A Secure Distributed Randomness Generation Protocol With High Practicality and Scalability
https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9252080
```
• To the best of our knowledge, this is the first work to build a security model for DRG protocols,which can be used as a general framework for security analysis of DRG protocols
• evaluation of SecRand by deploying it on a laptop with a Windows 10 environment in the C language
• Experimentaldata showed that SecRand-ZK had a higher space occu-pation and a lower computing resource occupation forthe underlying public bulletin board, whereas SecRand-Pairing was the opposite
• Weconsider static adversaries that will corrupt a certain numberof participants before the protocol execution begins
• Honest participants follow the protocol strictly and willnot reveal any private data to anyone else. They make upa majority of all participants, i.e.,n≥2t−1, which isusually referred to as the honest majority assumption
• Corrupted participants have three types of maliciousbehaviors, namely, refusing to participate in the proto-col, sending invalid data during the execution process,and revealing private data and colluding to perform acoordinated attack
• SecRand consists of three phases, namely, Distribution,Verification, and Reconstruction
• GenPf() andVerPf() denote the generation andverification process of the data validity proof, respectively.The final output computation is denoted asFinalOpt()
```
• SecRand = variant of Scrape = commit-recovery instead of commit-reveal-recovery
• Assumes public bulletin board (blockchain) while deprecating point-to-point messaging channels
• 2 constructions: SecRand-ZK and SecRand-Pairing a la Scrape
• Their PBB includes some calculation functionality (Verify)
• Uses advantage (interesting definition) to define availability and others
• Guaranteed output delivery also defined BUT meaning seems different (more like consistency)?!
• (g, h) = (Schoenmakers G, Schoenmakers g)
• Misleading communication complexity b/c assumes a blockchain

26. RANDCHAIN: Decentralised Randomness Beacon from Sequential Proof-of-Work
https://eprint.iacr.org/2020/1033.pdf
```
• Unlike existingDRB protocols where nodes arecollaborative, i.e., contribut-ing local entropy and aggregating them to a single output,nodes inRANDCHAINarecompetitive
• To propose a random output, a nodeneeds to solve a SeqPoW puzzle derived from the last randomoutput and the node’s identity
• With Nakamoto con-sensus,RANDCHAINdoes not rely on trustworthy leadersor lock-step synchrony, and achieves linear communicationcomplexity
• DRG-based DRBs sufferfrom two limitations, namelyround synchronisationand highcommunication overhead; In addition,to agree on random outputs, nodes have to make all-to-allbroadcasts, leading to communication complexity of at least O(n2)
• However, in order to collaborate, nodes shouldcontinuously broadcast messages to and synchronise with eachother. The former incurs at least quadratic communicationcomplexity, and the latter introduces the round synchronisationproblem
• All extra designs incorporated with DRG – e.g., usingleaders [41–43, 49, 54, 64, 67, 68, 72, 95], sharding [68, 95],cryptographic sortition [67], Byzantine consensus [67, 93],and erasure coding [42, 43] – aim at reducing the impact ofthe above two limitations. However, since all of them are inthe collaborative design, they inherently suffer from the twolimitations and cannot address them completely
• As 1) nodes cannotpredict who will become the next leader, 2) the leader cannotpredict random outputs produced by itself, and 3) before beingreplaced by a new leader, the leader can only produce a limitednumber of random outputs (following the Poisson distributionlike in Nakamoto consensus [66, 80, 91]), random outputs re-main unpredictable and unbiasible
• Unlike existing time-sensitive cryptographic primitives such as Proofof Sequential Work (PoSW) [51, 78] and Verifiable DelayFunctions (VDFs) [34, 87, 98], SeqPoW takes a random andunpredictable (rather than fixed) number of steps
• This makes SeqPoW useful for constructing other protocolssuch  as  leader  election  and  Proof-of-Stake  (PoS)-basedconsensus
• We introduce the concept of SeqPoW, including formal-isation, two  constructions  based on  VDFs  [87, 98]  andSloth
• we show that in a cluster with up to1024nodes, a random output can be propagated to the majorityof nodeswithin 1.3 seconds
• VDFs are usually constructed from an iteratively sequentialfunction (ISF) and a succinct proof attesting the ISF’s execu-tion results
• Compared to existing PoSW constructions [51, 78] whereproofs are not unique,SeqPoWSlothprovides unique outputs
• Predictable PoS-based consensus is vul-nerable to a class of prediction-based attacks, and thereforetolerates less Byzantine mining power [29] than PoW-basedconsensus. To make PoS-based consensus unpredictable,one can randomise the process of selecting block proposers.SeqPoW can provide such functionality: each node solvesa SeqPoW with its identity, the last block, and the difficultyparameter  inversely  proportional  to  its  stake  as  input,and the first node solving its SeqPoW becomes the blockproposer
• Verification is fasterthan computing: on cyclic groupG, squaring isO(log|G|)times  faster than  square  rooting
• To make the solutionunique,SeqPoWSlothonly treats the first solution satisfyingthe difficulty as valid. When verifyingSi, if the verifier findsan intermediate outputSj(j<i) satisfying the difficulty, thenSiis considered invalid
• The advantage of IVC-based SeqPoW is that it supports anyISFs. This means IVC-based SeqPoW can be more egalitarianby  using  ISFs  that  are  hard  to  parallelise  and  optimise.However,  IVC  is  usually  constructed  from  complicatedcryptographic primitives, such as SNARKs [33, 37, 38, 81, 96],making it inefficient and challenging to implement
• IfInit(·),Solve(·)andProve(·)take the public key rather than the secret key as input,then the construction cannot preventoutsourcing
• As long as secret keys are kept in secret, the adversary cannot execute VRFHash(·) for other nodes. This modification introducesnegligible   overhead  toSeqPoWVDF,  but  non-negligibleoverhead toSeqPoWSloth, as the verifier should verify all VRFoutputs and proofs for assuring no prior solution satisfies thedifficulty. More efficient non-outsourceable unique SeqPoWconstructions are considered as future work
• Nodepkruns  two  rou-tines:  the  synchronisation  routineSyncRoutine(·)and themining routineMineRoutine(·)
• RANDCHAIN, for the first time, achieves miningnon-parallelisable. This is because 1) each node has a uniqueinput of the PoW puzzle, and 2) the PoW puzzle is sequential
• Similar  toPoSpace-based Nakamoto consensus, the optimal attack onRANDCHAINis thegrinding attack: the adversary allocatesa processor to mine on each of existing blocks. Comparedto  51%  attacks  on  PoW-based consensus, grinding  attackamplifies the adversary’s mining power by up to e
• We  implement  the  the  SeqPoW  con-structions in Rust. We use therug[6] crate for big integerarithmetic, and implement the RSA group with 1024-bit keys
• A network is lock-step synchronous ifthe protocol executes in rounds and all messages are deliveredbefore the end of each round; is synchronous if messages aredelivered within a known finite time-bound; is asynchronousif messages are delivered without a known time-bound; or ispartially synchronous [58] if messages are delivered within aknown finite time-bound with some clock drift
```
• Table 1: collaborative vs competitive (RandChain)
• SeqPoW (!= PoSW): not necessary (i.e. RandChain can be instantiated with PoW)
• Permissioned network rather than permissionless
• Table 3: SeqPoW vs other similar primitives
• (SeqPoW_VDF, SeqPoW_Sloth) = (non-unique output, unique)
• LS synchrony = lock-step synchrony
• ISF: iteratively sequential function
• Valid tuple = honest tuple + is indeed a solution
• SeqPoW properties: completeness, soundness, hardness, sequentiality, uniqueness (optional)
• Interesting framework: say (probabilistic/deterministic, parallelizable/sequential) = (0/1, 0/1) -> [PoW, PoSW, VDF, SeqPoW] = [(0, 0), (0, 1), (1, 1), (0.5, 1)]
• SeqPoW is more "fair" compared to VDF?
• Using VRF (to use sk) instead of H (with pk) can prevent outsourcing
• Idea: replace nonce-incrementing part of PoW with VDF/Sloth
• Figure 3: seems like every miner starts with different seed albeit same previous block hash
• 2 sources of "entropy" (leading to fairness <-> monopoly): different seed & different hash(input) < target even if same VDF chain
• 2 hash functions involved: target & randomness
• DRB properties: consistency, liveness, fairness, uniform distribution, unpredictability
• Says unbiasability is a special case of unpredictability (but seems not)?!
• Grinding attack (also selfish mining) mentioned as the most optimal attack?
• Seems vulnerable to withholding attack without incentive
• Table 5: comparison of protocols
• Classification of "DRBs from external entropy" is interesting, but claims that it's not publicly verifiable (it is?)

27. RandChain: Practical Scalable Decentralized Randomness Attested by Blockchain
https://eprint.iacr.org/2021/450.pdf
```
• We  propose  a  sharding-based  scheme,RandChain,  to  obtain  a  practical  scalable  distributedand   decentralized   randomness   attested   by   blockchain   in   large-scaleapplications.  In  RandChain,  we  eliminate  the  use  of  computation-heavycryptographic operations, e.g., Publicly Verifiable Secret Sharing (PVSS),in prevalent approaches. We build a sub-routine,RandGene, which utilizesacommit-then-revealstrategy  to  establish  a  local  randomness,  enforcedby efficient Verifiable Random Function (VRF). RandGene generates therandomness  based  on  statistical  approaches,  instead  of  cryptographicoperations, to eliminate computational operations
• RandChain maintainsa two-layer hierarchical chain structure via a sharding scheme. The firstlevel  chain  is  maintained  by  RandGene  within  each  shard  to  provide  averifiable randomness source by blockchain. The second level chain usesthe  randomnesses  from  each  shard  to  build  a  randomness  chain
• In  this  paper,  we  propose  to  utilize  blockchain  as  the“trusted entity” to generate good randomness
• We assume the overall communicationnetwork is based on the synchrony, as defined in [11], in which thereexists  a  fixed  bound,∆,  on  a  message’s  traversal
• We aim the RandChain, with a fixed number of participating nodes,at  a  permissioned  blockchain  setting  (e.g.,  requiring  authenticationand  authorization  for  membership).  Especially,  RandChain  uses  acommit-then-revealmechanism to generate randomness, with the helpof VRF, and it then uses a Byzantine Fault Tolerant (BFT) protocol tobuild a blockchain to secure the protocol’s output
• The  participating  nodes  are  uniformly  shardedinto  distinct  committees  (alternatively  called  “shards”),  and  eachcommittee maintains its own local blockchain. The local blockchainruns  aRandGeneprotocol,  which  is  used  to  generate  a  “good”local  randomness
• We have two types of epochs: one is the sub-epochewithin each shard(the basic unit for the second-layer blockchain, shard blockchain); theother  is  the  epochEfor  overall  shards  (the  basic  unit  for  the  first-layer  blockchain,  RandChain)
• RandGene  protocol  itself  can  be  imple-mented  as  a  consensus  protocol  to  form  a  blockchain  to  record  therandomness. Our overall RandChain is used to provide a continuousrandomness beacon based on the local chain
• adversary can perform a grindingattack [5] [15], in which an adversary can try multiple times to get asolution that can benefit its choice. For example, the adversary mayprepare multiple random valuesvij, and chooses the one which canbias  the  final  result.  Our  scheme  can  prevent  this  kind  of  attack  bythe  design  of  stringxijand  the  system  model
• Ifa node receives multiple distinct random values from the same node,e.g.,sm,  with  a  correct  signature  for  one  sub-epoch,  then  the  nodewill discard all random values from the nodesm. When a node detectsthis  kind  of  attack,  it  can  optionally  mark  this  node  as  a  maliciousnode
• To  reduce  thecommunication  overhead  among  shards,  we  need  to  elect  a  leader,as the representative of that shard, to participate in the formation ofthe  RandChain  among  distinct  shards.  Also,  we  need  a  consensusprotocol  to  achieve  an  agreement  between  them
• In  our  shard-based  hierarchicalstructure, each shard as a whole can be considered as one participatingnode   of   RandChain
• Our RandChain protocolis based on a BFT protocol, taking the advantages of instant finality
```
• 4 properties: public verifiability, bias-resistance, unpredictability, availability
• Says VRF is a much more lightweight tool to use than VSS/PVSS (e.g. RandHound takes 6 steps)
• Byzantine model: f < n / 3
• Permissioned (similar to RandChain1)
• 6 phases of RandGene: propose, pre-commit, release, re-commit, cast, commit
• Q. what if hash mod k during cast does not yield distinct values?
• Figure 1 (overview) & 2 (cast)
• Commit phase's verification/consensus process doesn't seem robust
• Mechanisms used: VRF -> min function -> XOR -> sharding & aggregation via BFT
• Weak logic for sharding -> issues: leader election / consensus
• Leader election per shard: lottery ticket via hashing involving node id
• Final randomness (not clear though): randomness from shards after per-shard RandGene -> BFT on the lowest VRF values -> the VRF-winning randomness
• Some probability proof for secure sharding (honest majority for each shard)
• Failure probability analysis
• Communication complexity: O(c * n) with each group size c
• Modern BFT protocols: linear communication complexity?!
• Idea (overall doesn't really use "commit-then-reveal"): many VRFs on known inputs -> take the min & XOR many minimums
• RandChain = sharding + inefficient version of Algorand (epoch-based multi-round Algorand & XOR)

28. Economically Viable Randomness
https://arxiv.org/pdf/2007.03531.pdf
```
• An EVR sourceguarantees (i) secrecy, assuring that the random bits are kept se-cret until some predefined condition indicates that they are safeto reveal (e.g., the lottery’s ticket sale closes), and (ii) robustness,guaranteeing that the random bits are published once the condi-tion holds
• We prove that following the protocol givesrise to a stable state, called Coalition-Proof Nash Equilibrium, fromwhich no coalition comprised of a subset of the players can agreeto deviate
• The registered accounts’ owners are the players thatrealize the EVR source. We use an escrow-mediated distributedkey generation (DKG) protocol [61, 70] in order to achieve robust-ness for high-stake lotteries despite using small deposits
• Our solution guarantees secrecy through a novelinforming mechanism that allows anyone who knows the randomvalue during the period when it should remain obscure to report iton the escrow contract for a substantial compensation, funded bythe players’ deposits
• number of coins that player i ∈ [N ]deposited as ai ∈N; We further assume that a player i has ei ≥ 0 external coins,namely, coins that i owns independently of the ones she depositedin the service’s account; The decentralization assumptioncaptures this notion quantitatively:∀i ∈[N ],ei +ai ≤n/3
• To keep the presentation concise,during most of this work, we discuss a single-shot version of the EVRsource. Later, in Section 6, we extend it to multi-shot EVR, in which asingle commitment corresponds to a sequence of random values
• Formally, illicit profit is the quantity a user gains when an EVRsource is used on top of the legitimate profit that the user wouldhave gained if an ideal source were used instead. The EVR smartcontract, I, evaluates the bound on the illicit profit that the EVRsource can sustain and publishes it in a variable we denote by P
• CU2. Fallback profit bound. If robustness breaks, the total illicitprofit gained by all users is less than P coins.CU3. Stealing bound. If (hiding) secrecy breaks, the total illicitprofit gained by all users is less than P coins
• Escrow-DKG assumes aneconomic model where all players are rational. Additionally, as itsname hints, it assumes a trusted escrow service that substitutes andenhances the broadcast channel usually assumed in these protocols.While runs of traditional DKG protocols always succeed, Escrow-DKG might fail.An Escrow-DKG run begins with a permission-less registrationphase (as defined for a service in Section 2.2), where players deposit1 coin per secret share they stand to obtain.; These shares correspond to x , and X =дx is publishedas part of the run
• P =n −t =n/3 is the bound on the illicit profitthat the EVR can sustain; ℓ=n is the informing reward
• The pending phase. When the commit phase completes successfully,Genters the pending phase. This phase is the crux of the protocol,when only the informing function G.inform(x,acc)can be called
• The informing mechanism nullifies this incentive by allowing any userwho knows x before cnd matures to publish it on G’s account for ahigh reward of ℓcoins (line 25)
• This is another form of collective punishment that Gen-forces. Note that in order for this to happen, players holding at leastn −t shares must refrain from participating in the DKGreveal run
• We note that in the DKGreveal run, players do not publish theirindividual shares on G. Rather, they exchange shares among them-selves off-chain, reconstruct x off-chain, and eventually publish xon G. The reason to do these steps off-chain is mostly a practicalone
• Collective punishment is inevitable in case secrecy is violated as itis impossible to detect which players colluded in order to break secrecy.Regarding robustness, we chose to take the collective punishmentapproach due to practical considerations
• Multi-Shot EVR Source; Following a commit run, the ith (successful) run of reveal computes σi =eval(SK,i)and publishes it on I
• To realize Escrow-DKG in Ethereum, we use the open-source Eth-DKG library of Asayag et al. [4] (we chose to use this library ratherthan a similar one due to Schindler et al. [60]; Eth-DKG is able to steer most of thiscomputational burden off-chain by taking an optimistic approach:It proceeds assuming that all players follow the protocol and allowsaccounts to file disputes in case they detect a problem
• The informing mechanism we propose in Sec-tion 4 is susceptible to front-running; To address this problem we employ a two phase commit-revealinforming mechanism
• In Bitcoin-basedlotteries [1, 11], deposits are very high – O(n2)where the jackpotand the number of participants are both O(n). In contrast, ourdeposits are 1 coin for a jackpot of O(n)with n participants. Andwhile in Zero-Collateral Lotteries [48] there are no deposits, theyhave limited scalability, as they require players to actively interacton-chain in O(logn)rounds
• A game-theoretic model wasalso considered in the context of Rational Secret Sharing (RSS)
```
• Idea: commit-inform-reveal
• Inform (win l = n) vs steal (win P = n / 3)
• Can deposit only one coin?
• DKGcommit -> DKGreveal -- using DKG as a commit-reveal scheme
• Figure 1: high-level "Markov chain" view of protocol
• 2 properties: secrecy (guaranteed via informing) & robustness (guaranteed via Escrow-DKG)
• Secrecy breaks -> informing -> collective punishment
• Robustness breaks (no reveal) -> collective punishment
• Limit n in order to limit P?!

29. Rational Threshold Cryptosystems
https://arxiv.org/pdf/1901.01148.pdf
```
• We propose a framework for threshold cryptosystems under a permissionless-economic model in which the participants are rational profit-maximizing entities. To date, threshold cryptosystems have been considered under permissioned settings with a limited adversary. Our framework relies on an escrow service that slashes and redistributes deposits to incentivize participants to adhere desired behaviors
• Our countermeasure to collusion is framing
• A rational threshold cryptosystem that has been widely studied is rational secret sharing [20,19,2,26,15]. There however, only a specific aspect of the problem is dealt with, namely that participants prefer to learn the secret alone. The objective of the protocol is to guarantee that all participants learn of the secret together. In particular, cooperation at unintended times is not an option under their model and is not considered
• The system designer’s only tool in shaping the behavior of the participants is the escrow service, which (unlike the participants) follows prescribed rules in the protocol without deviations
• In Satoshi’s example, collusion is manifested by reconstructing the secret while Satoshi is still alive
```
• Framing = informing
• Need t + 1 to recover
• Their assumption (adversary does not need to be limited by t) != usual threshold assumption
• Collusion (for illicit profit) vs robustness (or lack thereof via no reveal)
• ∃escrow service (& complaint mechanism -> slashing) in their model
• Escrow-DKG might fail
• Figure 1: Escrow-DKG (= DKG + extra commitment/verification/complaint steps + encryption of fᵢ(j) via each pk)
• Idea: framing is better than colluding so nobody colludes
• Table 1: details on complaints (more DKG-specific) and framing (more application-specific?)

30. Secure Multiparty Computations on Bitcoin
https://eprint.iacr.org/2013/784.pdf
• Discussion of input scripts when redeeming txn
• Idea1: commit-reveal-punish; need O(n^2) deposit
• Timed commitment (their version): commit-reveal but $ goes to someone else if no reveal; hash-based implementation
• Idea2: 2-party lottery via no deposit but automatic loss if no reveal + private channel (to blockchain) assumption