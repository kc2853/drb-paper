General notes
• (unpredictable, unbiasable, unstoppable) = (1, 0, 1): RANDAO, Algorand, PoW
• (unpredictable, unbiasable, unstoppable) = (1, 1, 0): Dfinity, Ouroboros
• From HydRand: liveness (a correct node knowing R_{r - 1} can know R_r) vs guaranteed output delivery (all correct nodes can output R_r at round r)
• Atomic broadcast ~= consensus (∃reductions both ways)
• Byzantine broadcast (BB): leader broadcasts
• Byzantine agreement (BA): everyone has inputs -> agree on output
• BB ~= leader sends once + BA
• 
• 
• 
• 

1. Feldman's VSS paper
https://www.cs.umd.edu/~gasarch/TOPICS/secretsharing/feldmanVSS.pdf
• Probabilistic encryption
• y_0 is not a commitment to s?
• A_j: permutation?
• SS + homomorphic encryption (DL, ECDL, RSA)

2. Pedersen's paper (DKG)
https://link.springer.com/content/pdf/10.1007/3-540-46416-6_47.pdf
• Parallel Feldman's
• Can get group secret without knowing individual secrets b/c sum of individual secrets

3. Gennaro's DKG (based on Pedersen)
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.134.6445&rep=rep1&type=pdf
• Joint-Feldman can allow biasing public key (how about private key?)
• Use Pedersen-style VSS (instead of Feldman's): 2 polynomials per player + Pedersen commitments + separate public key extraction step (Step 4)
• 3 correctness properties: 1. can recover the same secret with any honest subset over threshold; 2. public key (g^{secret}) extractable; 3. secret is uniformly distributed
• (C1') > (C1)
• Secrecy property: no information on x is leaked except for public key; simulator SIM argument involved
• Communication model (fully sync), adversary model (static vs adaptive)
• Explains why SIM fails for Joint-Feldman
• Gennaro's DKG: proving correctness properties & secrecy property; remark on generation of h: requires a distributed coin flipping protocol?!
• 2 applications: ElGamal/DSA (randomizer); proactive secret sharing & signature (refresh phase)
• Extension to adaptive adversary: modification to public key extraction step
• Security in partial sync model (Δ)

4. Dfinity
https://dfinity.org/pdf-viewer/library/dfinity-consensus.pdf
• 4 layers
• 1. Identity layer: pseudonymous, register w stake
• 2. Random beacon layer
• 3. Blockchain layer
• 4. Notary layer
• Threshold relay, committee to committee
• Random beacon output -> block proposals -> block notarizations
• Threshold sig: 2 attacks (prediction & aborting); non-interactiveness; uniqueness
• Joint-Feldman DKG: yields a verification vector (commitment to final coefficients)
• Sign with individual share on group poly -> can combine bc homomorphic?
• Final signature: depends on current round number + previous number
• drand vs Dfinity: Pedersen/Gennaro DKG vs Joint-Feldman DKG -- not sure

5. Gennaro's DKG Revisited paper
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.12.5426&rep=rep1&type=pdf
• Gennaro's DKG (with Pedersen-VSS): secure but twice more expensive
• Schnorr threshold sig: still secure with Ped-DKG (which uses Feldman-VSS); using 2 DKGs (b/c temp secret key) -> signature
• "Additive" share pooling (paper uses this) vs "polynomial" share pooling
• Setup: computational, communication, adversary, DL assumption, security of threshold sig, simulation proof technique, ROM
• Generalized presentation of the 1/2 -> 3/4 attack for biasing Joint-Feldman
• <"secrecy-like" property of this protocol is good enough> -- adversary cannot bias the public key too much either?!
• Main idea: Joint-Feldman should be good enough (even if biasing possible) for threshold sig -> ex: Schnorr threshold sig with additive pooling
• Notion of security for threshold sig: robustness & unforgeability -> proving threshold Schnorr's security via SIM
• Tradeoff: security reduction leads to degradation by a factor compared to security of DLP (discrete log problem) -> need stronger security parameter -> bigger field -> less efficiency

6. ETHDKG paper
https://eprint.iacr.org/2019/985.pdf
• Joint-Feldman DKG + Neji
• Correctness, uniformity, robustness (works even if up to t invalid shares), liveness
• Send encrypted(!) shares via Diffie-Hellman
• Dispute phase: NIZK for DH key (to prevent false accusation)
• Neji: use new generator h (broadcasted later) for group public key; NIZK to show relationship between g & h
• Sign with individual share (on the group poly) not individual secret key?!
• mpk and mpk* (bc Neji and pairing-based?)

7. Schoenmakers PVSS paper
https://www.win.tue.nl/~berry/papers/crypto99.pdf
• PVSS assumes public broadcast
• Chaum-Pedersen subprotocol (DLEQ) for NIZK
• Totally separate individual key pairs for everyone
• Distribution phase (NIZK for encrypted shares) + reconstruction phase (NIZK for decrypted shares)
• Secret shares are different from other protocols
• Share pooling first (via dealer) -> publish share + decryption proof later (not clear from paper)? -- secret can be public?
• Can reuse individual key pairs
• Complexity O(nk) & security theorems (DDH assumption + ROM assumption)
• Z_p not mentioned but still is?
• Alternative scenario: secret not random but from small (potentially not uniformly distributed) set
• G^s (secret) != g^s
• Section 5: electronic voting; voters = dealers while talliers = participants; cheating talliers can know each voter's vote though?
• Section 6: threshold Binding ElGamal, threshold revocable electronic cash, threshold software key escrow

8. RandHerd paper
https://eprint.iacr.org/2016/1067.pdf
• 512 distributed servers -> 32 groups -> every 6 seconds
• Schoenmakers PVSS
• TSS (threshold Schnorr sig) & CoSi (collective signing = multisig aggregation + communication tree)
• TSS: VSS (+ additional VSS for short-term secret / random number) -> sign with poly share of secret -> reconstruct via Lagrange?
• RandShare: quasi-DKG but BA (Byzantine agreement) & computes all individual secrets (from individual poly) to compute group secret (sum of indiv secrets)
• RandHound: PVSS groups (parallel PVSS within groups); final random = product of PVSS secrets (Schnorr only for intermediary steps)?!
• RandHerd: RandHound for random permutation?; TSS groups; TSS-CoSi; group leader vs cothority; final random = Schnorr sig on timestamp
• Leader election (dubious) via VRF possible

9. Scrape paper (Cardano?)
https://eprint.iacr.org/2017/216.pdf
• O(nt) exponentiations -> O(n)
• Guaranteed output delivery?
• DDH + ROM or DBS (decisional bilinear square) in the plain model
• Public bulletin board model
• Inner product: share vector & dual's codeword
• Exact number of computations
• Adversarial model (static)
• Coding theory basics
• 3 properties for a PVSS scheme: correctness, verifiability (high probabilistic), IND1-secrecy
• Commitment definition, DLEQ definition
• Shamir's SS ~= Reed-Solomon error correcting code?!
• Scrape's (DDH) PVSS = Schoenmakers PVSS - many exponentiations of poly coeff commitments + Reed-Solomon ECC (hence faster verif complexity)
• Pairing-based (DBS) PVSS = Scrape's DDH PVSS - DLEQ NIZK + pairing + final secret in the form of pairing (not sure why)
• Scrape's randomness protocol (n parallel PVSS): commit -> reveal -> recovery (final random = product of PVSS secrets)
• Commit-reveal (basically) but other players can reconstruct your share if you don't reveal later

10. HydRand
https://eprint.iacr.org/2018/319.pdf
• Scrape's PVSS but no trusted dealer (but actually seems like they have trusted dealer?)
• Byzantine agreement variant?: "defers consensus decisions for up to f + 1 rounds"
• Guaranteed output delivery
• Permissioned setting (fixed players)
• Each round of protocol has 3 phases: propose -> acknowledge -> vote
• Propose: leader proposes a "dataset" which includes his secret (seed for PVSS) value from previous (when its commitment was published already!)
• Acknowledge: each node verifies leader's proposal
• Vote: each node verifies acknowledgement status of other nodes (may involve recovery stage via PVSS in case secret not received)
• Final random = H(previous round's random || PVSS group secret)
• Leader selection (non-interactive): take the most recent random number modulo |potential leader set|
• Potential leader set = all nodes - previous leaders that failed but got reconstructed - leaders for the past f rounds
• Attacker in round r can only attempt to affect round >= r + f + 1
• Hence the claim no trusted dealer
• No DKG
• Drawback: can't trust first f founds then? why not similar attacks later?

11. Dodis VRF
https://eprint.iacr.org/2004/310.pdf
• VUF (~= unique signature): replace VRF's pseudorandomness with unpredictability
• VUF = just the "proof" part of their VRF construction
• So can hash a unique sig (VUF) to get VRF

12. Kate poly commitment
https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf
• PolyCommit_DL, PolyCommit_Ped
• ZKS (zk set), nearly ZKS (length is leaked), ZK-EDB (zk elementary database)
• CES (content extraction signature), selective show
• Dynamic accumulators
• DL & t-SDH (t-strong Diffie-Hellman) assumptions
• Features: additive homomorphism, unconditional hiding (if only a few evaluations revealed), trapdoor commitment, batch opening (~= batch verification)
• Applications: 1. VSS; 2. nearly ZKS / ZK-EDB; 3. selective show (have Trent sign poly commitment, then prove ɸ(i) = m_i => no need to show all messages!)

13. DVRF-DRB
https://eprint.iacr.org/2020/096.pdf
• Strong pseudorandomness: adversary has (limited) oracle access to PartialEval
• 2 proposed DVRF: DDH-DVRF, GLOW-DVRF
• 3-5x faster than Dfinity
• Cryptographic lib: MCL, RELIC, Libsodium
• DistKG -> PartialEval -> Combine -> Verify
• 1. DDH-DVRF: DistKG (secret key is share on group poly) -> PartialEval (hash to the power of secret key, proof is DLEQ NIZK) -> Combine (check NIZK) -> Verify
• 2. GLOW-DVRF: DistKG (intro of g_2 and pairing a la Neji for Verify public key later) -> PartialEval (hash ^ secret, NIZK) -> Combine (NIZK) -> Verify (pairing)
• Difference in Dfinity-VRF: Combine also uses pairing to prove => less efficient
• Modified BLS (more efficient): GLOW-DVRF - last step's hash
• Algorand DRB is not strongly pseudorandom?
• Harmony: uses VDF?!
• HERB (homomorphic encryption random beacon): uses ElGamal encryption

14. Timed Commitments
https://www.iacr.org/archive/crypto2000/18800237/18800237.pdf
• Verifiable recovery (just recovery) + recovery with proof (outsiders can verify too) + immunity against parallelism
• Contract signing, honest auction
• Timed signature (with a new definition of valid signature) < timed commitment
• ∃zk proof that the scheme is a timed commitment (from Alice before she commits)
• Think about original definition of commitment b/c timed commitment is unorthodox
• Basic idea: open (allows faster verification) vs forced open (verifier needs to compute the "VDF")
• Q. Pietrzak's & Wesolowski's can help with efficient verification?

15. RandRunner
https://eprint.iacr.org/2020/942.pdf
• Strongly unique trapdoor VDFs
• No need for continuous Byzantine agreement (BA) due to pseudorandomness <-> true randomness requires some form of BA -- interesting!
• Strong uniqueness: unique even if public parameters adversarially generated (whatever that means); allows result obtained via trapdoor = that by evaluation (what's a counterexample?)
• Wesolowski's is not strongly unique, but Pietrzak's is
• ZKP for safe primes (by Camenisch and Michaels): ensures strong uniqueness?
• Lemma 1: proving strong uniqueness not just uniqueness
• Possible attacks: bias, predict, stall, trick others into accepting bogus
• Countermeasures to adversary selectively sending round output: 1. reliable broadcast O(n^2); 2. gossip protocol O(n log n) -- includes some references
• Unpredictability bounds for RR (round robin) & RS (randomized sampling)
• Note on Unicorn protocol: good for infrequent randomness scenarios
• The entire randomness beacon is essentially a (deterministic) "hash chain" with trapdoor VDFs such that no one person can be super ahead in the chain
• Information theoretically, no randomness?!
• Mathematical bounds for how much one can get ahead
• But dependent on Δ_VDF which is unknown

16. RandPiper
https://eprint.iacr.org/2020/1590.pdf
• GRandPiper (Good): PVSS / static adversary; BRandPiper (Better): VSS(?) / adaptive adversary (can predict for GRandPiper) / but sacrifices complexity a bit
• Quadratic communication per round without using threshold sig
• Reconfiguration friendly (dynamic set of nodes)
• Goal: good communication complexity (quadratic for worst case too); efficient cryptographic scheme (e.g. not VDF); reconfiguration friendly
• SMR (state machine replication) protocol
• Can reduce communication via erasure coding scheme or accumulators
• GRandPiper: PVSS encryption vector; additional "votes"; "to all the honest nodes" (how?); leader doesn't repeat for t epochs (a la HydRand?); Even can corrupt the next t leaders & predict
• BRandPiper: iVSS (improved VSS; modified version of eVSS = Kate poly commitment?); homomorphic sum; leader can secret share n shares at once (key insight)
• HydRand: cubic communication complexity worst case; t < n / 3 (but t < n / 2 for RandPiper)
• "Buffering": using last d-th time a node was a leader -> buffer d shares?

17. On Bitcoin as a public randomness source
https://eprint.iacr.org/2015/1015.pdf
• At least 68 bits of min-entropy -> can extract 32 near-uniform bits
• Single-bit lottery: safe up to 50 BTC
• NIST, Random.org, stock market used for election in Takoma Park, BitcoinMegaLottery
• Extractor (sufficient entropy number -> high entropy number)
• Attacks: block withholding attack (could be non-miners in the bribing attacker model); P2P DoS attack (worst-case: Dolev-Yao attacker); idea of transition pruning (lottery as Markov trees & transition matrix)
• Miners use "trusted peers" already
• Proposition (on Bitcoin): OP_BEACON

18. Homomorphic Encryption Random Beacon
https://eprint.iacr.org/2019/1320.pdf
• Threshold ElGamal
• Provides true randomness as opposed to pseudorandomness
• Slightly more practical communication complexity as a tradeoff

19. SPURT: Scalable Distributed Randomness Beacon with Transparent Setup
https://eprint.iacr.org/2021/100.pdf

20. Random Oracles in Constantinople: Practical Asynchronous Byzantine Agreement using Cryptography
https://allquantor.at/blockchainbib/pdf/cachin2000random.pdf

21. RANDCHAIN: Decentralised Randomness Beacon from Sequential Proof-of-Work
https://eprint.iacr.org/2020/1033.pdf

22. A Pragmatic Introduction to Secure Multi-Party Computation
https://securecomputation.org/docs/pragmaticmpc.pdf
• One interpretation of MPC: participants "secret-share" the inputs/outputs to an MPC protocol
• In practice, participants usually secret-share the inputs in a way that those shares would eventually lead to a correct output
• In other words: instead of input -> f(input) = output, we have something like input -> modified input (an input "share") -> modified output (an output "share") -> output
1) Yao's garbled circuits
• Alice (key generator) & Bob (evaluator)
• Secret sharing: done via Alice's key generation (thus Bob can't know Alice's input) & Alice's oblivious transfer to Bob (thus Alice can't know Bob's input)
• Idea: input -> modified input (used to encrypt the MPC function) -> use modified input to decrypt the MPC function -> output
2) GMW (Goldreich-Micali-Wigderson) protocol
• Secret sharing: done via additive shares (involving randomness) on wires/gates
• Idea: input -> modified input (add with randomness) -> modified output (output share) -> output (randomness cancels out)
3) BGW (Ben-Or-Goldwasser-Wigderson) protocol
• Secret sharing: Shamir's(!) per participant
• Idea: input -> modified input (Shamir shares) -> modified output = f(modified input) -> output (Lagrange interpolation)
• Lindell in his survey paper Secure Multiparty Computation (MPC) notes that this method is not only general, but also the most efficient in practice more often than not?
• Multiplication gates suffer from complexity in BGW due to its degree-reduction step -> optimization using Beaver triples & pre-processing phase
• GMW & BGW suffer b/c number of rounds depends on circuit depth -> BMR (Beaver-Micali-Rogaway) protocol where Yao's garbled circuits idea is generalized to be distributed & parallel -> constant round
• Some techniques turning semi-honest security into malicious security: cut-and-choose, GMW compiler, MPC in the head (state-of-the-art?)
• For outputting an arithmetic sum: #3 (BGW) is relatively more efficient? -> basically repeated iterations of DKG

