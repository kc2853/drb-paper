%!TEX root = main.tex

\section{Preliminaries}
\label{section:preliminaries}
% We delineate the necessary preliminaries in this section, starting with the description of our system model (including threat model) relevant in all protocols portrayed in this paper (unless stated otherwise). We then introduce a strawman DRB assuming a perfectly synchronous network (with zero latency) as well as the classical commit-reveal~\cite{blum1983coin}. Identifying problems in both, we define the security of an ideal DRB.
\subsection{System Model}
We consider a system with a fixed set of $n$ participants $\nodes = \{P_1, P_2, ..., P_n\}$ (also called nodes).
We may also write $\nodes = \{1, 2, ..., n\}$ for the purpose of algebraic formulations without loss of generality.
Of the $n$, up to $t$ nodes may be \emph{faulty} (also called \textit{malicious} or \textit{Byzantine}) and engage in incorrect (arbitrary) behavior during a protocol run. An adversary $\adv$ that controls up to $t$ such nodes is called \textit{$t$-limited}. Otherwise, nodes that are \textit{honest} abide by the specified protocol.

We assume a standard public key infrastructure (PKI) such that all nodes know each others' public keys, and that all nodes are connected via point-to-point secure (providing authenticity) communication channels. All messages exchanged by honest nodes are digitally signed by the sender, and recipients always validate each message before proceeding. By default, we assume a \textit{synchronous} network, in which there exists some known finite message delay bound $\Delta$. This means that an adversary can delay a message by at most $\Delta$.

Moreover, we assume a computationally bounded adversary $\adv$ which runs in probabilistic polynomial time (PPT). In particular, this means $\adv$ cannot break standard cryptographic constructions such as hash functions, digital signatures, etc. 
For delay-based protocols, we also assume the adversary cannot compute delay functions in fewer than $T$ time steps.
The three ways in which $\adv$ can deviate from a protocol are omitting a message (i.e. \textit{withholding attack}), sending invalid messages, and colluding to coordinate an attack based on private information shared among malicious nodes. Additionally, $\adv$ has the power to perform a \textit{grinding attack}, in which $\adv$ privately precomputes and iterates through polynomially many combinations of inputs to an algorithm in order to derive a desirable output. By default, we assume a \textit{static} adversary that chooses nodes to be corrupted before a protocol run whereas an \textit{adaptive} adversary can choose nodes to be corrupted at any time during a protocol run (we assume a model where nodes remain corrupted once corrupted).

We denote our computational model's security parameter by $\lambda$. We call a function $\negl(\lambda)$ \textit{negligible} if for all $c > 0$ there exists a $\lambda_0$ such that $\negl(\lambda) < \frac{1}{\lambda^c}$ for all $\lambda > \lambda_0$. The group elements $g, h \in \groupG$ are generators of $\groupG$ while $p, q$ denote primes where $q \mid p - 1$ (unless stated explicitly) such that $\groupG_q$ is a group of prime order $q$. The notation $tuple[0]$ denotes the first element of $tuple$. Furthermore, we model any hash function $H(\cdot)$ as a random oracle. %\todo{add ROM to appendix?}. %JOE-I think this is okay for now.
In the context of a distributed randomness beacon, we use $\epochv$ to denote \epoch number and $\drboutput_\epochv$ to denote the \textit{beacon output} (i.e. the distributed randomness output) in \epoch $\epochv$. The \textit{entropy-providing committee} denoted by $\committee_\epochv$ refers to a subset of nodes (hereafter called \textit{entropy providers}) that proactively generate and provide marginal entropy in \epoch $\epochv$. %$\committee_\epochv$ can include all nodes, some but not all nodes, one node (i.e. a leader), or no node.

\subsection{Strawman Protocol: Rock-Paper-Scissors}
Distributed randomness assuming perfect synchrony is straightforward. Consider the following one-round protocol where each participant $i$ broadcasts its \textit{entropy contribution} (i.e. independently generated randomness) $e_i \sample \groupZ_p$ to every other participant at the same time. The protocol's random output $\drboutput$ is calculated (via modular addition in $\groupZ_p$) as:
\begin{equation}
\label{equation:addall}
\drboutput = \sum_{i = 1}^n e_i
\end{equation}

Repeating this protocol periodically would yield a DRB.
This protocol is simple---in fact, it is essentially what humans approximate when playing rock-paper-scissors (with $e_i \sample \groupZ_3$).
Under a perfect synchrony assumption, is secure as long as any single participant chooses its $e_i$ randomly. However, security falls apart completely once messages can be delayed.
%assumption is never true. In fact, situations can change dramatically in a practical setting where participants can go offline (perhaps temporarily) due to network failure, messages can be delayed either non-significantly or significantly, and Byzantine attackers can try to predict or bias the randomness to their benefit.
Consider a simple scenario with three participants $\{P_1, P_2, P_3\}$ participating to produce $\drboutput = e_1 + e_2 + e_3$. If $P_3$ can read $e_1$ and $e_2$ before sending $e_3$ (due to non-zero message latency) to $P_1$ and $P_2$, then $P_3$ can fix the output $\drboutput$ to any value $\tilde{\drboutput}$ by choosing $e_3 = \tilde{\drboutput} - e_1 - e_2$. Effectively, the protocol cannot tolerate any malicious participants without perfect synchrony.
Indeed, humans may attempt to cheat in rock-paper-scissors by quickly adjusting their play in reaction to what their opponent is playing.

\subsection{Commit-Reveal}
\label{subsection:commit-reveal}
A classic fix for the above issue is to introduce a cryptographic commitment step before each party reveals its entropy contribution.
\begin{enumerate}
\item \underline{Commit}. Each participant $P_i$ broadcasts a cryptographic commitment $C_i = \mathsf{Com}(e_i, r_i)$ (with fresh randomness $r_i$) to its entropy contribution $e_i$ rather than $e_i$ itself. Note that $\mathsf{Com}(x, r_0)$ denotes a cryptographic commitment to $x$ with hiding and binding properties~\cite{blum1983coin,damgaard1998commitment}.
\item \underline{Reveal}. Once all participants have shared their corresponding commitments, each participant $P_i$ then opens its commitment by revealing the pair $(e_i, r_i)$. In turn, $P_i$ verifies each received pair $(e_j, r_j)$ for $j \neq i$ by recomputing $C_j = \mathsf{Com}(e_j, r_j)$. Given that these checks pass, the final output $\drboutput$ can canonically be computed via the aforementioned Equation~\ref{equation:addall}. If any of the checks do not pass, however, the protocol aborts and outputs $\perp$.
\end{enumerate}

With the additional commit step, it becomes impossible for any participant to manipulate the output $\drboutput$, as their values are bound by commitments published before any participants reveal. Nonetheless, the protocol can still be biased, as the last participant $P_k$ to reveal can in fact compute $\drboutput$ earlier than others and hence can decide to withhold (not reveal) $(e_k, r_k)$ if $\drboutput$ is not to its liking. This is called the \textit{last-revealer attack}. Note that this attack is indistinguishable from an honest node going offline, and indeed the protocol also has no robustness against non-Byzantine faults in this basic form.

\subsection{Ideal Distributed Randomness Beacon}
Clearly, a DRB should prevent any one participant from tampering with (e.g. predicting, biasing, or aborting) each \epoch's output. The beacon output should also be verifiable by \todo{remove}any third party. Based on these requirements, the overall security properties of an ideal DRB are given by the following.

\begin{figure}[h]
\begin{center}
\framebox{
\begingroup
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l}
\underline{$\gamedrbsecurity(\lambda)$}\\
$pp_\epochv \gets \drb^\epochv.\mathsf{Setup}(\lambda)$\\
$\sigma \gets \adv_0(pp_\epochv)$\\
$\drboutput_{\epochv, 1} \gets \drb^\epochv_{\adv_1(\sigma) \cup \left(\nodes\setminus\adv_1(\sigma)\right)}$\\
$\drboutput_{\epochv, 0} \gets \drb^\epochv_{\nodes}$\\
$b' \gets \adv_2(\sigma, \drboutput_{\epochv, b})$\\
Return $b = b'$
\end{tabular}
\endgroup}
\end{center}
\caption{Security game for DRB's unbiasability security property.}
\label{figure:unbias}
\end{figure}

\begin{definition}[Ideal distributed randomness beacon]
A distributed randomness beacon is \textit{ideal} or \textit{secure} if it satisfies the following security properties.
\begin{enumerate}
\item Unbiasability.
A DRB is \textit{unbiasable} if, for any PPT adversary $\adv = (\adv_0, \adv_1, \adv_2)$, the following advantage (see Figure~\ref{figure:unbias}) given by
\begingroup\makeatletter\def\f@size{8}\check@mathfonts
\begin{equation*}
\advdrbsecurity(\lambda) = \left|\Pr\left[\gamedrbsecurityone(\lambda) = 1\right] - \Pr\left[\gamedrbsecurityzero(\lambda) = 1\right]\right|
\end{equation*}\endgroup
is negligible, i.e. $\advdrbsecurity(\lambda) < \negl(\lambda)$.

% \item Unpredictability. Similarly, $\adv$ cannot predict any $c$ bits of $\drboutput_\epochv$ with probability greater than $\frac{1}{2^c} + \negl(\lambda)$. The protocol satisfies \textit{$d$-unpredictability}~\cite{bhat2020randpiper} for $d \in \mathbb{N}$ if this is true for any round greater than or equal to $r + d$ (where $\epochv$ denotes the current round).
\item Liveness. We define liveness~\cite{guo2020secRand} by requiring that the advantage of $\adv$ denoted by $Pr[\drboutput_\epochv = \text{$\perp$}]$ (i.e. the probability that the honest beacon output at the end of \epoch $\epochv$ is null) is negligible, given a DRB that runs among honest participants and $\adv$.

\item \todo{separate unpred/pseudorandom?}
\end{enumerate}
\end{definition}

In the security game $\gamedrbsecurity$ depicted in Figure~\ref{figure:unbias}, the adversary algorithm $\adv_0$ first outputs an advice string ($\sigma$) given DRB's public parameters $pp_\epochv$ in \epoch $\epochv$ as input (which may or may not include the previous beacon output, list of participants in \epoch $\epochv$, the identity of the \epoch leader, etc. depending on protocol specifications).
The advice string acts as a biasing ``strategy'' and is taken by $\adv_1$, which then corrupts up to $t$ nodes in the honest node set $\nodes = \{1, \dots, n\}$, interacts with $\nodes\setminus\adv_1$, and outputs the beacon output $\drboutput_{\epochv, 1}$.
In contrast, $\drboutput_{\epochv, 0}$ denotes the honest beacon output generated by $\nodes$ (and not involving $\adv_1$).
Then $\adv_2$ distinguishes the two cases given the same advice string.
A DRB is secure in terms of unbiasability if the adversary can do so with negligible probability.

We next begin our discussion of various approaches to an ideal DRB, starting with protocols based on delay functions.

