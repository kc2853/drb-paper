%!TEX root = main.tex

\section{Discussions}
\label{section:discussions}
We provide a historical account of the distributed randomness line of research, compare all aforementioned DRBs in Table~\ref{table:comparison}, and explore some practical issues with DRBs.

\subsection{Relation to Collective Coin Flipping Protocols}
Conceptually, distributed randomness is not a new line of research.
With its roots in Blum's classic work on coin flipping over telephone~\cite{blum1983coin}, distributed randomness has in fact been much researched albeit in a different context elaborated below.
Namely, Ben-Or and Linial in their seminal work~\cite{ben1985collective,ben1989collective} introduced the \textit{full information} model for the \textit{collective coin flipping} problem, in which $n$ participants with unbounded computational power communicate only via a single broadcast channel to generate a common random bit (such that honest majority is required~\cite{saks1989robust,boppana2000perfect} and thus assumed).
Numerous works exist in this setting, largely classifiable into different types of adversaries dealt with: static~\cite{ben1989collective,ajtai1993influence,kahn1989influence,saks1989robust,alon1993coin,boppana2000perfect,feige1999noncryptographic,russell1999lower}, adaptive~\cite{ben1989collective,lichtenstein1989some,goldwasser2015adaptively,dodis2000impossibility,kalai2021lower,haitner2020tight}, and variants of adaptive~\cite{mahloujifar2019can,etesami2020computational,cleve1993martingales,aspnes1998lower,goldwasser2015adaptively}.
See~\cite{kalai2021lower,haitner2020tight} for this line of research.

Overall, these works concern upper and lower bounds on corruption threshold, bias (deviation from coin flipping probability 1/2), and round complexity, all of which provide interesting theoretical insights.
Nonetheless, these bounds are often asymptotic (hence not practical) and are grounded in a more lax definition of security where it is sufficient that bias is bounded (but can still be nontrivial).
This is in contrast to the literature on DRBs considered in this paper, where we require each protocol to be as \drbsecure as possible, outputting multi-bit, have explicit round complexity and fault tolerance, and assume computationally bounded adversaries in a cryptographic setting as well as point-to-point communication channels in the first place.
The goal is to achieve fully functional and practical DRBs.

Outside the full information model (such that cryptography is allowed) and thus the honest majority assumption, the well-known lower bound by Cleve~\cite{cleve1986limits} states that for any $r$-round coin flipping protocol there exists an efficient adversary that can bias the output of an honest node by $\Omega(1 / r)$.
In other words, it is impossible to have an \drbsecure coin flipping protocol with a dishonest majority.

While this may seem to contradict the fault tolerance of delay-based DRBs from Section~\ref{section:delay}, we note that delay functions help circumvent Cleve's impossibility result in the following two ways.
First, timed commitments allow recovery of a value that is withheld (either due to honest or Byzantine fault) and lost from an honest node's perspective.
In Cleve's proof, the notion of a ``default bit'' is used in such withholding situation whereas timed commitments effectively deprecate this default bit mechanism, sidestepping the proof logic.

Second, an implicit assumption in Cleve's model is that a Byzantine node is capable of grinding through possibilities to its liking and can arbitrarily choose which messages to output based on inputs from other nodes that are honest.
However, VDFs limit this capability such that it is not possible for even a dedicated attacker to grind through possibilities in an attempt to fix an output of some computation if a VDF is applied.
As a result of above, delay-based DRBs are able to enjoy both the highest fault tolerance and \drbsecurity without violating any classical lower bounds.

\subsection{Grinding Attack}
In a grinding attack, an adversary can search over many possible inputs to broadcast in a given \epoch, with the possibility of influencing the outcome. While grinding attacks are not a threat in commit-reveal-recover variants or protocols with no marginal entropy, they are a valid concern in committee-based protocols involving random selection (RS), a private lottery, or a beacon output generated by precommitted per-node entropy. The idea is that an adversary can grind to produce a biased $\committee_\epochv$, $\drboutput_\epochv$, or both (leading to a vicious cycle).
% \joenote{What about the countermeasure of just making grinding statistically not effective for a subexponential adversary?}
% \kevinnote{can mention quantum/exponential adversary later?}

Two countermeasures are possible. First, inclusion of fresh marginal entropy from at least one honest node can be required, in which case grinding fails due to the adversary's inability to control such entropy. Second, precommitted entropy must indeed be precommitted, in which case grinding vacuously fails due to the lack of any grindable entropy.
\begin{enumerate}
\item \textbf{Requirement of fresh marginal entropy from at least one honest node.} Due to the $t$-limited adversary assumption, it is possible to force the inclusion of fresh marginal entropy from at least one honest node if we require more than $t$ entropy providers each \epoch. Such a requirement is used in protocols like RandHound (where committee selection via LS has a size requirement) and Ouroboros (where the size of each epoch can be made large).
\item \textbf{Requirement of precommitted entropy.} No grindable entropy naturally means no possible grinding attack. In HydRand (and similarly GRandPiper), it is required that the precommitted entropy ($e_{\tilde{\epochv}}$ from $\drboutput_\epochv = H(\drboutput_{\epochv - 1} \mathbin\Vert h^{e_{\tilde{\epochv}}})$ as per Section~\ref{subsubsection:precommitted}) used in \epoch $\epochv$ is precommitted in \epoch $\tilde{\epochv}$ where $\epochv - \tilde{\epochv} > t$ owing to $t$-\interunpredictability. In the protocols based on private lottery (i.e. Algorand, Ouroboros Praos, and Caucus), the private inputs to the lottery (VRF's $sk$ or each $h_\epochv$ of a hash chain) are fixed in advance to make them ungrindable.
\end{enumerate}

\subsection{Withholding Attack}
\label{subsection:withholding}
In a withholding attack, an adversary can influence the outcome by not publishing some information. Any leader-based protocol is vulnerable due to the inherent reliance on a leader's availability, affecting the protocol's liveness (as well as unbiasability and potentially unpredictability). Any protocol with a private lottery is also fundamentally vulnerable.
\begin{enumerate}
\item \textbf{Protocols with a leader.} RandHound, RandHerd, and SPURT suffer from the leader unavailability issue in case the leader withholds its message such that their liveness is affected and a beacon output can be aborted (depending on implementation).
% In RandHound and RandHerd, this can create a bias if the leader aborts after seeing $\drboutput_\epochv$.
A fallback is needed in case a leader withholds (e.g. HydRand's PVSS recovery).
\item \textbf{Protocols with a private lottery.} The issue of withholding is more fundamental with private lottery schemes like Algorand, as there is no accountability. There are two possible remedies. First, we can require all participants to post their lottery outputs every single \epoch even if they lose the lottery, in which case any lack of message would be indicative of withholding. However, this incurs communication cost, negating the advantages of a private lottery. Second, SSLE (single secret leader election)~\cite{boneh2020single} can be used to guarantee one winner per \epoch, enabling detection of withholding.
% In a nutshell, SSLE ensures exactly one leader from a group is randomly chosen while the identity of the leader will only be known when the winner publicly reveals its identity.
The guarantee of one winner as opposed to the expectation of one winner is what differentiates SSLE. While this makes withholding obvious, it does not prevent withholding by itself, nor does it detect \emph{who} withholds in the case of withholding.
\end{enumerate}

\begin{table*}[h!]
% \footnotesize
\scriptsize
% \tiny
\begin{threeparttable}
\caption{DRB Comparison}
\label{table:comparison}
% \begin{tabularx}{\textwidth}{@{} l *{20}c}
% \begin{tabularx}{\textwidth}{@{} l *{20}{@{\phantom{x}}c@{\phantom{x}}}}
\begin{tabularx}{\textwidth}{@{} l *{20}{@{\phantom{w}}c@{\phantom{w}}}}
\toprule
\spheading{} & \spheading{Section\\(from paper)} & \spheading{Cryptographic Primitive} & \spheading{Fault Tolerance (less than)} & \spheading{Independent Participation} & \spheading{Per-Epoch Entropy Provider} & \spheading{$\alpha$-\Intraunpredictability} & \spheading{$\beta$-\Interunpredictability} & \spheading{Immunity to Withholding} & \spheading{Verifier Complexity} & \multicolumn{2}{c}{\spheading{Communication Complexity}} & \spheading{Max Damage} & \spheading{Recovery Cost}\\
\cmidrule{11-12}
 & & & & & & & & & & Optimistic & Worst & & \\
\toprule
Commit-Reveal & \hyperref[subsection:commit-reveal]{II} & Commitment & 1 & \cmark & All & $O(\Delta)$ & 1 & \xmark & $O(n)$ & $O(n^2)$ & $O(n^3)$ & Bias & $O(1)$ \\
\midrule
Unicorn++ & \multirow{4}{*}{\ref{section:delay}} & VDF & $n$ & \cmark & All & $O(\Delta)$ & 1 & \cmark & $O(n)$ & $O(n^2)$ & $O(n^3)$ & None & $O(1)$ \\
Ext. Beacon+VDF & & VDF & $n$ & \cmark & External & $O(\Delta)$ & 1 & \cmark & $O(1)$ & $O(n)$ & $O(n^2)$ & None & $O(1)$ \\
RandRunner & & Trapdoor VDF & $n$ & \xmark & None & $T$\tnote{‡} & $t$\tnote{§} & \cmark & $O(\log T)$\tnote{‡} & $O(n)$ & $O(n^2)$ & Predict & $O(n^3)$ \\
Bicorn & & Timed commitment & $n$ & \cmark & All & $T$\tnote{‡} & 1 & \cmark & $O(n)$ & $O(n^2)$ & $O(n^3)$ & None & $O(1)$ \\
\midrule
RANDAO & \multirow{2}{*}{\ref{section:commit-reveal-punish}} & Commitment & $n$ & \cmark & All & $O(\Delta)$ & 1 & \cmark & $O(n)$ & $O(n^2)$ & $O(n^2)$\tnote{†} & None & $O(n)$\tnote{†} \\
EVR & & Escrow-DKG & $n/3$ & \xmark & All & $O(\Delta)$ & 1 & \cmark & $O(n^3)$ & $O(n^3)$ & $O(n^4)$ & None & $O(n)$ \\
\midrule
Scrape & \multirow{5}{*}{\ref{section:commit-reveal-recover}} & PVSS & $n/2$ & \xmark & All & $O(\Delta)$ & 1 & \cmark & $O(n^2)$ & $O(n^3)$ & $O(n^4)$ & Bias\tnote{r} & $O(n^3)$ \\
Albatross & & PVSS & $n/2$ & \xmark & All & $O(\Delta)$ & 1 & \cmark & $O(1)$ & $O(n)$ & $O(n^2)$ & Bias\tnote{r} & $O(n^3)$ \\
RandShare & & (P)VSS & $n/3$ & \xmark & All & $O(\Delta)$ & 1 & \cmark & $O(n^3)$ & $O(n^3)$ & $O(n^4)$ & Bias\tnote{r} & $O(1)$ \\
SecRand & & PVSS & $n/2$ & \xmark & All & $O(\Delta)$ & 1 & \cmark & $O(n^2)$ & $O(n^3)$ & $O(n^4)$ & Bias\tnote{r} & $O(n^3)$ \\
HERB & & Thr. ElGamal & $n/3$ & \xmark & All & $O(\Delta)$ & 1 & \cmark & $O(n)$ & $O(n^2)$ & $O(n^3)$ & Bias\tnote{r} & $O(n^4)$ \\
\midrule
HydRand & \multirow{11}{*}{\ref{section:committee-based}} & PVSS & $n/3$ & \xmark & Committee\tnote{*} & $O(\Delta)$ & $t$ & \cmark & $O(n)$ & $O(n^2)$ & $O(n^3)$ & Bias & $O(n^3)$ \\
GRandPiper & & PVSS & $n/2$ & \xmark & Committee\tnote{*} & $O(\Delta)$ & $t$ & \cmark & $O(n^2)$ & $O(n^2)$ & $O(n^2)$ & Bias & $O(n^3)$ \\
BRandPiper & & (P)VSS & $n/2$ & \xmark & Committee\tnote{*} & $O(\Delta)$ & 1 & \cmark & $O(n^2)$ & $O(n^2)$ & $O(n^3)$ & Bias & $O(n^4)$ \\
Ouroboros & & PVSS & $n/2$ & \xmark & Committee & $O(\Delta)$ & 1 & \cmark & $O(n^2)$ & $O(n^3)$ & $O(n^3)$\tnote{†} & Bias & $O(n^2)$\tnote{†} \\
RandHound & & PVSS & $n/3$ & \xmark & Committee & $O(\Delta)$ & 1 & \xmark & $O(c n)$ & $O(c^2 n)$ & $O(c^2 n^2)$ & Bias & $O(n^3)$ \\
SPURT & & PVSS & $n/3$ & \xmark & Committee & $O(\Delta)$ & 1 & \xmark & $O(n)$ & $O(n^2)$ & $O(n^2)$ & Bias & $O(n^3)$ \\
OptRand & & PVSS & $n/2$ & \xmark & Committee & $O(\Delta)$ & 1 & \cmark & $O(n)$ & $O(n^2)$ & $O(n^2)$ & Bias & $O(n^3)$ \\
Algorand & & VRF & $n/3$ & \cmark & Committee\tnote{*} & $O(\Delta)$ & 1 & \xmark & $O(1)$ & $O(n)$ & $O(n)$\tnote{†} & Bias & $O(n^2)$\tnote{†} \\
Ouroboros Praos & & VRF & $n/2$ & \cmark & Committee & $O(\Delta)$ & 1 & \xmark & $O(n)$ & $O(n^2)$ & $O(n^2)$\tnote{†} & Bias & $O(n^2)$\tnote{†} \\
Caucus & & Hash chain & $n/3$ & \cmark & Committee\tnote{*} & $O(\Delta)$ & 1 & \xmark & $O(1)$ & $O(n)$ & $O(n^2)$ & Bias & $O(n^3)$ \\
NV++ & & VRF, thr. ElGamal & $n/3$ & \xmark & Committee & $O(\Delta)$ & 1 & \xmark & $O(n)$ & $O(n)$ & $O(n)$\tnote{†} & Bias & $O(n^2)$\tnote{†} \\
\midrule
drand & \multirow{5}{*}{\ref{section:dvrf}} & Thr. BLS & $n/2$ & \xmark & None & $O(\Delta)$ & 1 & \cmark & $O(1)$ & $O(n^2)$ & $O(n^3)$ & Predict & $O(n^4)$ \\
RandHerd & & Thr. Schnorr & $n/3$ & \xmark & None & $O(\Delta)$ & 1 & \xmark & $O(1)$ & $O(c^2 n)$ & $O(n^4)$ & Bias & $O(n^4)$ \\
DDH-DRB & & DDH-based DVRF & $n/2$ & \xmark & None & $O(\Delta)$ & 1 & \cmark & $O(n)$ & $O(n^2)$ & $O(n^3)$ & Predict & $O(n^4)$ \\
GLOW-DRB & & Pairing-based DVRF & $n/2$ & \xmark & None & $O(\Delta)$ & 1 & \cmark & $O(1)$ & $O(n^2)$ & $O(n^3)$ & Predict & $O(n^4)$ \\
Strobe & & RSA, VSS & $n/2$ & \xmark & None & $O(\Delta)$ & 1 & \cmark & $O(1)$ & $O(n^2)$ & $O(n^3)$ & Predict & $O(n)$ \\
\bottomrule
\end{tabularx}
\begin{tablenotes}[flushleft,para]
\item $c$ is the size of a shard in RandHerd and RandHound. We assume a leader can be Byzantine for both.
\item Albatross' verifier and communication complexities are per beacon output.
\item In Ouroboros and Ouroboros Praos, we assume the number of slot leaders in an \epoch is denoted by $n$.
\item We assume Scrape's PVSS~\cite{cascudo2017scrape} is used as the default PVSS scheme.
\item[*] Each committee consists of a leader by default or by expectation.
\item[†] PBB (public bulletin board) is assumed.
\item[‡] $T$ denotes VDF's delay parameter, and verification of Pietrzak's VDF is logarithmic in $T$.
\item[§] $\beta = t$ for RandRunner's $\beta$-\interunpredictability assuming a dishonest minority without any computational advantage. See~\cite{schindler2021randrunner} for more scenarios.
\item[r] In a non-rushing adversary model, max damage would be predict rather than bias.
\end{tablenotes}
\end{threeparttable}
\end{table*}

\subsection{Adaptive Security}
\label{subsection:adaptive}
A DRB is \textit{adaptively secure} if its security properties remain unaffected against an adaptive adversary instead of a static one.
Here, we discuss a way to remedy adaptive attacks.

\begin{enumerate}
% \item \textbf{$|\committee_\epochv|$ is greater than $t$ or equal to 0.}
% Due to the $t$-limited adversary assumption, a large enough $\committee_\epochv$ (or an empty one as per Section~\ref{section:dvrf}) guarantees adaptive security. Otherwise, a protocol may be vulnerable. In HydRand and GRandPiper (where $|\committee_\epochv| = 1$), an adaptive adversary can corrupt the next $t$ \epoch leaders to predict $t + 1$ future \epochs. In Ouroboros, it can adaptively corrupt the entire $\committee_\epochv$ (which could probabilistically be less than or equal to $t$ in size) publicly known in advance.
\item \textbf{Requiring lottery winners (in protocols with private lotteries) to broadcast marginal entropy and proof of selection into $\committee_\epochv$ in the same message.} While some private lottery schemes may involve less than or equal to $t$ entropy providers per \epoch, the fact that one message (per entropy provider) comprises both announcement of winning the lottery and provision of marginal entropy allows adaptive security. By the time an adversary knows which nodes to corrupt adaptively in an \epoch (after the nodes reveal their identity as entropy providers), there is no extra step left to be corrupted. A similar line of research has recently emerged in the MPC literature~\cite{gentry2021yoso}.
% \item \textbf{There is no central point of dependency in any step of the protocol.} In leader-based protocols where a leader functions more as an orchestrator than an entropy provider, participating nodes may still need to depend on the leader to make progress on the beacon such that an adversary can adaptively corrupt such leaders to its benefit. In RandRunner, corrupting the next $t$ leaders allows predictability. In RandHound and RandHerd, corrupting the \epoch leader allows biasability if the leader aborts after seeing $\drboutput_\epochv$ as aforementioned. In SPURT, corrupting the next $t$ leaders to withhold endangers liveness.
\end{enumerate}

On the one hand, it is important for the sake of adaptive security that there is no central point of dependency in any step of a protocol.
Otherwise, participating nodes depend on the leader (functioning as either an orchestrator or an entropy provider) such that an adversary can adaptively corrupt such leaders.
On the other hand, we note that a proof of adaptive security does not follow immediately from a protocol's lack of leaders and can in fact be tricky to show.
Only recently has it been shown that threshold BLS is adaptively secure~\cite{bacho2022adaptive}.

\subsection{Comparison of DRBs}
Table~\ref{table:comparison} provides an overall comparison of DRBs. \textit{Fault Tolerance} indicates the minimum number of faulty nodes that can abort a protocol (after the initial setup). Protocols with \textit{Independent Participation} allow a node to contribute to beacon output without the knowledge of other nodes in advance. However, it differs from a permissionless setting in the sense that a node may still have to register in advance to allow verification of its contribution.

\textit{Verifier Complexity} refers to the computational cost for a passive node (third party) to verify a beacon output. We exclude the cost associated with the initial setup for both verifier and communication complexities. We assume a verifier complexity of $O(n)$ per Lagrange interpolation or Scrape's PVSS~\cite{cascudo2017scrape} run. \textit{Communication Complexity} concerns bitwise point-to-point communication among nodes by default. Alternatively, we consider a \textit{public bulletin board} (PBB) (e.g. blockchain) as a reliable information exchange medium in protocols where it is intrinsic. In a PBB model, we consider both the bitwise writing cost (amount of data posted to PBB) and reading cost (by all nodes where each node only reads data relevant to it). In the absence of PBB, Byzantine consensus~\cite{castro1999practical} incurs $O(n^2)$ cost per decision by default.

\textit{Max Damage} refers to the maximum damage possible when $n - 1$ rushing~\cite{gennaro1999secure} (where an adversary delays sending messages until \textit{after} reading messages sent by the honest nodes in a given round of communication) adversarial nodes cooperate to predict or bias.
The reason for this column is to observe the consequence of when the honest majority assumption breaks down, and the reason for the notion of rushing is that there can exist a separation between what rushing versus non-rushing adversaries can do especially in protocols from Section~\ref{section:commit-reveal-recover}: if the adversary is able to generate its entropy contributions after seeing (or otherwise simultaneously with) all the honest nodes' entropy contributions, then biasing (or otherwise predicting) is possible.
The same fundamental reasoning applies to (for instance) Ouroboros, where the maximum damage is bias due to the fact that slot leaders (i.e. entropy providers) communicate in sequential slots (and hence the adversary can reconstruct and see an honest node's entropy contribution before generating its own).
In escrow-based protocols, we assume the adversaries are rational.

\textit{Recovery Cost} refers to the communication cost associated with recovering from an adversarial corruption.
Regenerating keys (e.g. $\mathsf{PVSS.KeyGen}$ or for private lottery schemes) and $\mathsf{VDF.Setup}$ incur $O(n^3)$ recovery cost without PBB (and $O(n^2)$ with PBB) while we conservatively assume each DKG incurs $O(n^4)$ recovery cost (although it can be optimized~\cite{gurkan2021aggregatable}).
Finally, we note that it is possible to employ multiple DRBs as subprotocols to a multi-tiered DRB (an approach taken by Mt. Random~\cite{cascudo2021mt}) in order to combine and take advantage of various DRB properties at the same time.
% \iffalse
% \subsection{Quality vs Efficiency}
% % Mt. Random's Tier 1 (fresh randomness per node) > 2 (one VRF, not biasable) > 3 (many VRFs, biasable via withholding) -- from quality of randomness perspective
% The protocols that we have seen so far provide a range of efficiency and quality trade-offs under different setups, assumptions and adversarial models. PVSS/VSS based protocols offers uniform randomness, but comes at quartic communication complexity.
% VRF based protocols require very little communication and computation but the output is biasable by withholding. DVRF based protocols get rid of the bias by allowing a set of participants greater than a threshold to recover the output. VDF based protocols require high computational cost (sequential squarings) but generates uniform pseudorandom outputs with quadratic communication cost. While these protocols can be used on their own, they can also be combined in a modular way to build a distributed randomness beacon. Mt. Random~\cite{cascudo2021mt}, a multi-tiered randomness beacon is one such example.

% \joenote{should there be a separate section on protocols that combine other protocols?}
% Mt. Random has three independent tiers, each based on a different technique and providing different trade-off between complexity and quality of randomness. Tier 1 provides uniform randomness via PVSS based protocols. Mt. Random reduces the amortized cost per beacon output for PVSS by using an extension of Albatross called GULL (Gradually UnLeashed aLbatross)~\cite{cascudo2021mt}, but could be substituted with any of the Commit-Reveal-Recover variants from Section~\ref{section:commit-reveal-recover}. Tier 2 provides uniform pseudorandomness via DVRF based protocols. Mt. Random uses DDH based version of drand, but any of the DVRF based protocols from Section~\ref{section:dvrf} or RandRunner from Section~\ref{subsection:randrunner} could be used instead. Tier 3 provides biased pseudorandomness using VRF based protocols. Mt. Random uses a variation of Ouroboros Praos where every participant computes and broadcasts their VRF outputs (and requires no committee selection via private lottery). Though this makes detecting malicious participants (and maybe punishing them) easier, the beacon output for the round would still remain biased. Randomness from earlier tiers are used to periodically refresh seeds for Tier 2 and Tier 3 protocols, making them more secure than their stand-alone versions.

% Mt. Random illustrates a framework in which PVSS and (D)VRF protocols can be combined in a multi-tiered fashion where higher tiers generate random outputs faster than lower tiers albeit with losses in randomness quality. It is possible to extend the framework to other primitives/building blocks or use an altogether different framework to combine different protocols. This remains to be explored further.
% \fi
